import * as SecureStore from 'expo-secure-store';
import React, { createContext, useContext, useEffect, useRef, useState } from 'react';
import { Alert, AppState } from 'react-native';

const SESSION_TIMEOUT = 1000 * 60 * 60 * 12; // 12 hours
const PIN_TIMEOUT = 1000 * 5 * 60; // 5 minutes

// âœ… Use your actual IP address instead of localhost
const API_BASE_URL = 'http://10.79.49.1:7001'; // Replace with your actual IP

// Create the AuthContext
export const AuthContext = createContext({
  user: null,
  showPinScreen: false,
  isLoading: false,
  login: () => {},
  logout: () => {},
  resetSessionTimer: () => {},
  resetInactivityTimer: () => {},
});

// Custom hook to use AuthContext
export const useAuth = () => {
  const context = useContext(AuthContext);
  if (!context) {
    throw new Error('useAuth must be used within an AuthProvider');
  }
  return context;
};

export const AuthProvider = ({ children }) => {
  const [user, setUser] = useState(null);
  const [showPinScreen, setShowPinScreen] = useState(false);
  const [isLoading, setIsLoading] = useState(false);

  const sessionTimerRef = useRef(null);
  const inactivityTimerRef = useRef(null);
  const appState = useRef(AppState.currentState);

  const login = async (agentno, password) => {
    setIsLoading(true);
    try {
      console.log('Attempting login to:', `${API_BASE_URL}/api/v1/agent/login`);
      
      const response = await fetch(`${API_BASE_URL}/api/v1/agent/login`, {
        method: 'POST',
        headers: { 
          'Content-Type': 'application/json',
          'Accept': 'application/json'
        },
        credentials: 'include',
        body: JSON.stringify({ agentno, password }),
      });

      console.log('Response status:', response.status);

      if (!response.ok) {
        const errorData = await response.json();
        return { success: false, error: errorData.message || 'Login failed' };
      }

      const result = await response.json();
      console.log('Login successful:', result);
      
      // Updated to match controller response structure
      const { agentname, agentno: agentNumber, mobileNumber, patsansthaName, patsansthaId } = result.data.agent;
      const { accessToken } = result.data;

      const userData = { 
        agentname, 
        agentno: agentNumber, 
        mobileNumber, 
        patsansthaName,
        patsansthaId,
        token: accessToken 
      };

      setUser(userData);
      await SecureStore.setItemAsync('session_user', JSON.stringify(userData));
      await SecureStore.setItemAsync('session_timestamp', Date.now().toString());

      resetSessionTimer();
      resetInactivityTimer();

      return { success: true };
    } catch (error) {
      console.error('Login error:', error);
      // More detailed error logging
      console.error('Error details:', {
        name: error.name,
        message: error.message,
        stack: error.stack
      });
      return { success: false, error: 'Network or server error' };
    } finally {
      setIsLoading(false);
    }
  };

  const logout = async () => {
    setIsLoading(true);
    try {
      if (user?.token) {
        await fetch(`${API_BASE_URL}/api/v1/agent/logout`, {
          method: 'POST',
          headers: {
            'Content-Type': 'application/json',
            Authorization: `Bearer ${user.token}`,
          },
          credentials: 'include',
        });
      }
    } catch (err) {
      console.warn('Logout failed:', err);
    } finally {
      setUser(null);
      await SecureStore.deleteItemAsync('session_user');
      await SecureStore.deleteItemAsync('session_timestamp');
      clearTimeout(sessionTimerRef.current);
      clearTimeout(inactivityTimerRef.current);
      setIsLoading(false);
    }
  };

  const resetSessionTimer = () => {
    clearTimeout(sessionTimerRef.current);
    sessionTimerRef.current = setTimeout(() => {
      Alert.alert('Session Expired', 'You have been logged out due to inactivity.');
      logout();
    }, SESSION_TIMEOUT);
  };

  const resetInactivityTimer = () => {
    clearTimeout(inactivityTimerRef.current);
    inactivityTimerRef.current = setTimeout(() => {
      setShowPinScreen(true);
    }, PIN_TIMEOUT);
  };

  const resumeSession = async () => {
    const storedUser = await SecureStore.getItemAsync('session_user');
    const storedTimestamp = await SecureStore.getItemAsync('session_timestamp');

    if (storedUser && storedTimestamp) {
      const timestamp = parseInt(storedTimestamp, 10);
      const currentTime = Date.now();

      if (currentTime - timestamp < SESSION_TIMEOUT) {
        const userData = JSON.parse(storedUser);
        setUser(userData);

        if (currentTime - timestamp > PIN_TIMEOUT) {
          setShowPinScreen(true);
        }

        resetSessionTimer();
        resetInactivityTimer();
      } else {
        logout();
      }
    }
  };

  const handleAppStateChange = (nextAppState) => {
    if (appState.current.match(/active/) && nextAppState === 'background') {
      SecureStore.setItemAsync('session_timestamp', Date.now().toString());
    }

    if (appState.current.match(/background/) && nextAppState === 'active') {
      resumeSession();
    }

    appState.current = nextAppState;
  };

  useEffect(() => {
    resumeSession();
    const subscription = AppState.addEventListener('change', handleAppStateChange);
    return () => subscription.remove();
  }, []);

  const contextValue = {
    user,
    showPinScreen,
    isLoading,
    login,
    logout,
    resetSessionTimer,
    resetInactivityTimer,
  };

  return (
    <AuthContext.Provider value={contextValue}>
      {children}
    </AuthContext.Provider>
  );
};

export default AuthProvider;